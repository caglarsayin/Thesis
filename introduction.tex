%!TEX root = thesis.tex
\chapter{Introduction}
The purpose of this chapter is to give introduction of the subject and challenge in question, as well as justification and motivation of its importance. The chapter also propose research question to guide the thesis.The purpose of this chapter is to give introduction of the subject and challenge

\subsection{Topic covered by the project}
This thesis is mainly about a novel approach to specially malware obfuscation methods although software obfuscation concept is the more broad topic. Malware is the short malicious software and can cover any program or script that is harmful to a system or its user. One of the biggest discussion is a definition of harmful on computer security. It is quite hard to define what harmful is and what malicious is. Because of the reason why we cannot classify software easily, whether malicious or not, the most efficient and suitable way to detect them is a black or white listing. Basically, there are predefined list of software which claims they are good or evil. This black lists are comprised with signatures of the software which are presumed malicious; then, we are looking for these signatures in our computers to detect malware. 

Even if these lists include every possible signature, malware can evade signature detection with obfuscating itself over and over again. For each attempt, it reproduces itself, and thus, it conceals the signature. However, there are many countermeasures against them\cite{moser2007limits}\cite{egele2012survey}. For example, memory dumping and scanning later is recently one of the trendy detection methods\footnote{Especially, after boot level rootkits.}. It is quite reasonable because while the malware is running over memory, it is naked and vulnerable.

In this thesis, we are seeking possibilities to enhance "Disk-memory level" to cache level. It is a pretty novel contribution to the computer security field because there have been a few works, so far, about what we are searching for.


\subsection{Keywords}
Security, Malware Design, Cache Oriented Polymorphism, Cache Coherency, Malware Evasion, Code Obfuscation

\subsection{Problem description}
The conventional PC architecture is now which security researchers, developers and malware authors familiar with. However, the density of development spreads around other architecture instead of common PC arch.. For example, mobile devices recently have much higher profile at this point comparing with our conventional desktop systems.Besides, hardware platforms especially for mobile devices are increasing in complexity and sophistication with the use of multi-processor systems becoming common place as well as the use of many layer  memory architectures, such as NUMA, caches for performance and efficiency(esp. on power consumption).This opens new opportunities for obfuscation and concealment of malware.

Apart from the basic signature-based methods known to be ineffective against unknown threats, there are two mainstream techniques to detect malicious code which are called static and dynamic analysis, but indeed, the main stream method is still signature-based ones. Static analysis identifies malware mainly with code flow graph and data flow graph obtained from static information, while dynamic analysis is taking account dynamic execution features. 

There are number of techniques for obfuscating, some relying on the precise properties of the hardware and its behaviours, that can render static analysis ineffective as well as signature analysis. Some of the key techniques deployed by malware authors for obfuscation do include race condition and exploitation of memory uses. The detection algorithms and techniques have been adequately worked so far because of the simplicity of our conventional architectures and using generic PC architecture despite these systems also started to become more heterogeneous(e.g. Intel Haswell). However, with increasing deployment of multi-processor computing and other parallel processing devices, the implementation of local memories like NUMA and caches are increasing in order to increase efficiently and performance and decrease power consumption. It is obviously clear that these features will also be exploited by malware authors at some point. The project seeks to investigate the feasibility of such malware both from a theoretical viewpoint and through the development of a proof-of-concept.

\subsection{Justification, motivation and benefits}
If malware designing is superficially considered, you could fall in the usual fallacy that it is not beneficial, and maybe it is malicious. However, if we can design it, there is always a more skillful malicious author who might already abuse this vulnerability on the black side of the moon. The duty we are actually obligated to discover these vulnerabilities and design countermeasure against them. In this way, our blessed motivation is finding possible vulnerabilities, and mitigate or eliminate their risk. Otherwise; if we are lucky, we might detect these zero time vulnerability attacks, yet it could be too late to fix and analyze them. Besides, for example, some of the most sensational and beneficial papers(\cite{moser2007limits},\cite{cavallaro2008limits},\cite{egele2012survey}) are criticizing malware with designing them as like as we do, and their values over computer security are undoubted today. 

In short, we are building brakes. Sometimes they are that thing slow us down, or sometimes they even stop us in our tracks. However, they are actually there to enable us to go faster and secure.

\subsection{Research questions}\label{research:questions}
\begin{enumerate}
	\item How can an an obfuscation method, which exploits caches to conceal itself from memory scanning systems, be designed for tightly coupled and multiprocessor systems?
	\item How can the efficiency optimisations of common cache coherency protocols found in multiprocessor and multi-core systems be exploited for probabilistically hiding and obfuscating malware?
	\item How can we execute deobfuscated code on the Harvard Architecture without leakage to upper memories?
\end{enumerate}


\section{Choice of methods}
	In order to solve our problems, we followed particular research methodologies for each question.

	In the first question, we limited the question with tightly coupled and multi-processor systems, and we chose the design science methodology to follow during our work and we supported it with literature review methodology. First, we started to seek cache memory architecture to understand how they work, interact with each other and affect performance. Then, we classified them in a proper way, and we noted all remarkable points in background studies chapter section 1. Besides, we try to seek practical implementation on new ARM based boards. We obtained ARM little big multi-processor based Samsung Exynos 5410 and 5420 systems on the chip boards to explore their cache memory implementation. Next, we proposed an attack vector under a constant isolated theoretical system which has the most basic tightly coupled, multiprocessor and Von Neumann architecture with write back cache policy and without cache coherency. At the end of the solution, we clearly stated possible implementation problems which we can encounter during implementation and gave references to the next questions.

	In the second question, we used literature which we have already researched, and we inspected the architectural detail of modern cache coherency techniques, especially snoopy cache coherency and multi-processor interconnector design in order to describe a model to exploit the efficiency optimization of common cache coherency protocols found in multiprocessor systems. When we used design science method in this chapter, we used a quantitative approach to measure possible interconnection network latency. This approach is prepared with a simulation experiment whose simulation tools have already been acknowledged by many processor producers as accurate on its latency cycle calculation. We totally designed 4 experiments which are crowded and small topologies with congested and silent traffics and present our results in Appendix B as well as Chapter 5. 
	At the end of the chapter, we built and designed a method to exploit the efficiency optimization of lazy cache coherency found in multiprocessor systems.

	For the third question, at the end of the literature overview, we found a similar cases\cite{sparks2005shadow}\cite{yan2008revealing}, which can empower our solution. The problem which we try to solve is not what they are trying to do, but it simultaneously solved our problem. We built our model and concluded interpretation approach which has been seen in previous studies with our own model. When we designed our own model, we used our attack vector which we proposed in Chapter 4 and merge it with a interpreter to execute the code in DCache, which we can access, load and store, but we cannot execute. At the end of the studies, we discussed and criticized practical issues which we can fall during the implementation of our theoretical model. 

\section{Thesis Outline}
	This section provide a brief summary listing of the content presented in this thesis. The listing is based on chapters, where each chapters and its content is described. First the related works and background studies are presented. Then, our designs is presented as well as further work and conclusion in a sequence. At the end of the thesis, we attached the simulation code which we wrote and the experiments results by Booksim v2.0 to appendix.
	
\begin{itemize}
	\item Chapter 2 is related works chapter, which presents the literature related to malware, code obfuscation and countermeasures against malware. Firstly, we give the malware self defense methods' literature, and then, we conclude it with malware analysis and detection methods' literature.
	\item Chapter 3 is background studies chapter, which presents the background knowledge to design the cache oriented obfuscation system. Our studies are highly related to computer architecture and organization knowledges. Firstly of all, we start with cache related studies. We explain the motivation of cache, how they are working. Then, we conclude them with details about caches. Secondly, we mention about cache coherency and consistency and this section involve with an explanation of snoopy cache coherency protocols. At the end of the chapter, we describe computer interconnection network's basics. This section highly involves with their design features and their effects on the interconnector performance.
	\item Chapter 4 is called "Cache Oriented Obfuscation". In short, this chapter defines the basics of our thesis. In the chapter, we propose a method to exploit tightly coupled multi-processor systems and explain details and the attack vector which we propose. At the end of the studies, we discuss the pitfalls and fallacies.
	\item Chapter 5 is the chapter which we try to solve our second research question. We propose a probabilistic attack method to hide or obfuscate malware. We also define several formulas in this chapter to measure coherency latencies. It also includes experiment results which we designed with a interconnection simulation tool, Booksim. At the end of the studies, we discuss the pitfalls and fallacies.
	\item Chapter 6 includes the answer of our third research question and proposes a solution for the Harvard Computer Architecture implementation issue. It includes some elementary studies about virtual machine designing and interpretation. At the end of the studies, we discuss the pitfalls and fallacies.
	\item Chapter 7 concludes and summarizes the most important findings in this thesis and add presents a range of topics that should be further work to better understanding of countermeasures and to implementing the theoretical studies which we proposed. 
	\item Appendix A is attached with the python code of simple cache simulation. We used this code to enhance our intuition over cache behaviors. It could be useful to proof our studies further.
	\item Appendix B includes the experiment results, which are very detailed, and configuration files to replicate it. It could be useful to proof our latency experiments and proposals further.
\end{itemize}
